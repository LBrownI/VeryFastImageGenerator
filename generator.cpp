#include <iostream> // For standard I/O (cout, cerr)
#include <string>   // For std::string
#include <queue>    // For std::deque (used as a queue)
#include <deque>    // For std::deque explicitly
#include <mutex>    // For std::mutex and std::lock_guard, std::unique_lock
#include <condition_variable> // For std::condition_variable
#include <chrono>   // For time-related operations (steady_clock, duration)
#include <iomanip>  // For I/O manipulators (setprecision, fixed)
#include <filesystem> // For filesystem operations (create_directories, exists)
#include <thread>   // For std::thread
#include <vector>   // For std::vector<std::thread>
#include <atomic>   // For std::atomic<int>
#include <opencv2/core.hpp>     // OpenCV core functionalities
#include <opencv2/imgcodecs.hpp> // OpenCV image reading/writing
#include <opencv2/imgproc.hpp>   // OpenCV image processing (though mainly randu is used here)

namespace fs = std::filesystem;

// Configuration: Number of threads dedicated to saving images.
const int NUM_SAVER_THREADS = 7;

// Structure to hold an image and its unique generation index.
// This is passed through the queue from the generator to savers.
struct ImageData
{
    cv::Mat image; // The OpenCV matrix holding image data.
    int index;     // Unique index of the image, used for naming files.
};

// Structure to hold arguments passed to the generator and saver threads.
struct ThreadArgs
{
    int width;             // Desired width of the generated images.
    int height;            // Desired height of the generated images.
    int duration_seconds;  // How long the image generation process should run.
    double fps;            // Target frames per second for image generation.
    std::string image_extension; // File extension for saved images (e.g., "png", "jpg").
    std::string output_directory; // Directory where images will be saved.
    int totalImages;       // Total images expected to be generated (fps * duration).
};

// --- Shared variables for inter-thread communication and synchronization ---

// Maximum number of images allowed in the queue. If full, oldest is dropped. 
// Could manually increase it if the computer can handle it.
const size_t MAX_QUEUE_SIZE = 100; 
// Queue to transfer ImageData from the generator thread to saver threads.
std::deque<ImageData> imageQueue;
// Mutex to protect access to shared resources: imageQueue and finishedGenerating flag.
std::mutex queueMutex;         
// Condition variable to signal saver threads when new images are available or generation is finished.
std::condition_variable queueCV; 
// Flag to indicate to saver threads that the image generator has finished its work.
bool finishedGenerating = false;   
// Atomic counter for the total number of images generated by the producer thread.
std::atomic<int> total_images_generated_count = 0; 
// Atomic counter for the total number of images successfully saved to disk by consumer threads.
std::atomic<int> total_images_saved_count = 0;     
// Atomic counter for images pushed into the queue by the generator.
std::atomic<int> total_images_enqueued_count = 0;
// Atomic counter for frames the generator skipped because it was falling behind the target FPS.
std::atomic<int> total_images_dropped_due_to_delay = 0;

/**
 * @brief Generates a random color image.
 * @param width Width of the image.
 * @param height Height of the image.
 * @return An OpenCV Mat object representing the generated image.
 */
cv::Mat generateRandomImage(int width, int height)
{
    cv::Mat image(height, width, CV_8UC3); // Create a 3-channel (color) image.
    // Fill the image with random pixel values (BGR order).
    cv::randu(image, cv::Scalar(0, 0, 0), cv::Scalar(255, 255, 255));
    return image;
}

/**
 * @brief Function executed by the image generator thread.
 * 
 * Generates images at a target FPS for a specified duration.
 * Puts generated images into a shared queue for saver threads to process.
 * Handles queue size limits and tracks generation statistics.
 * 
 * @param args ThreadArgs structure containing generation parameters.
 */
void imageGenerator(ThreadArgs args)
{
    auto start_generation_timer = std::chrono::steady_clock::now();
    // Calculate the duration of a single frame based on the target FPS.
    std::chrono::duration<double> frame_duration(1.0 / args.fps);

    int i = 0; // Counter for generated images (used for indexing).
    auto start_time = std::chrono::steady_clock::now();
    // Calculate the time when the generation should stop.
    auto end_time = start_time + std::chrono::seconds(args.duration_seconds);

    // Loop until the specified duration has elapsed.
    while (std::chrono::steady_clock::now() < end_time)
    {
        auto current_time = std::chrono::steady_clock::now();
        // Calculate the ideal time at which the next frame *should* be generated.
        auto next_frame_time = start_time + frame_duration * (i + 1);

        // --- FPS Control Logic ---
        // If the current time is already past the ideal time for the next frame,
        // it means we're falling behind. Skip this frame.
        if (current_time > next_frame_time)
        {
            total_images_dropped_due_to_delay++; // Increment counter for skipped frames.
            i++; // Still increment image index to maintain sequence for subsequent frames.
            continue; // Skip to the next iteration to try for the next frame.
        }

        // Wait/sleep until the ideal time for the next frame arrives.
        // This helps maintain the target FPS if generation is faster than required.
        std::this_thread::sleep_until(next_frame_time);
        
        // Generate the actual image.
        cv::Mat image = generateRandomImage(args.width, args.height);

        // --- Critical Section: Accessing the shared queue ---
        {
            std::lock_guard<std::mutex> lock(queueMutex); // Lock the mutex to protect the queue.
            // If the queue has reached its maximum allowed size, remove the oldest image.
            if (imageQueue.size() >= MAX_QUEUE_SIZE)
            {
                imageQueue.pop_front(); // Remove from the front (oldest).
            }
            // Add the new image to the back of the queue.
            imageQueue.push_back({image, i});
            total_images_enqueued_count++; // Increment count of images put into the queue.
        } // Mutex is automatically released here by lock_guard.

        // Notify one or all waiting saver threads that a new image is available.
        // notify_all() is used here; notify_one() could be an alternative if only one saver
        // is expected to wake up and process efficiently.
        queueCV.notify_all(); 
        total_images_generated_count++; // Increment overall count of generated images.
        i++; // Increment image index for the next image.
    }

    // --- Post-generation: Signal savers that generation is complete ---
    {
        std::lock_guard<std::mutex> lock(queueMutex); // Lock to safely modify finishedGenerating.
        finishedGenerating = true; // Set the flag.
    }
    queueCV.notify_all(); // Notify all saver threads so they can check the flag and exit if queue is empty.

    // Calculate and print generation summary.
    double generation_time_seconds = std::chrono::duration<double>(std::chrono::steady_clock::now() - start_generation_timer).count();
    double effective_fps = 0;
    if (generation_time_seconds > 0)
    {
        effective_fps = total_images_enqueued_count.load() / generation_time_seconds;
    }

    std::cout << "--- Resumen generación (hilo generador) ---\n";
    std::cout << "Imágenes objetivo a generar: " << args.totalImages << "\n";
    std::cout << "Imágenes realmente generadas y encoladas: " << total_images_generated_count.load() << "\n";
    std::cout << "Imágenes descartadas por atraso (no encoladas): " << total_images_dropped_due_to_delay.load() << "\n";
    std::cout << std::fixed << std::setprecision(2)
              << "Tiempo de generación del hilo: " << generation_time_seconds << " segundos\n";
    std::cout << std::fixed << std::setprecision(2)
              << "FPS efectivo generación (reloj del hilo): " << effective_fps << "\n";
}

/**
 * @brief Function executed by each image saver thread.
 * 
 * Continuously fetches images from the shared queue and saves them to disk
 * until the generator signals completion and the queue is empty.
 * 
 * @param args ThreadArgs structure containing output directory and image extension.
 * @param saver_id A unique ID for the saver thread (for logging purposes).
 */
void imageSaver(ThreadArgs args, int saver_id)
{
    while (true)
    {
        std::unique_lock<std::mutex> lock(queueMutex); // Acquire lock to check queue and wait.
        // Wait on the condition variable. The thread will sleep until:
        // 1. The queue is not empty (an image is available), OR
        // 2. The `finishedGenerating` flag is true (generator is done).
        // The lambda predicate prevents spurious wakeups.
        queueCV.wait(lock, []
                     { return !imageQueue.empty() || finishedGenerating; });

        // --- Process images currently in the queue ---
        // This inner loop ensures all available images are processed after a wakeup
        // before re-evaluating the main loop condition (especially `finishedGenerating`).
        while (!imageQueue.empty())
        {
            ImageData imgData = imageQueue.front(); // Get image from the front of the queue.
            imageQueue.pop_front();                 // Remove it from the queue.
            lock.unlock(); // IMPORTANT: Unlock the mutex while saving the image (I/O bound, can be slow).
                           // This allows other savers or the generator to access the queue.

            // Construct the filename.
            std::string filename = args.output_directory + "/image_" + std::to_string(imgData.index) + "." + args.image_extension;
            // Save the image to disk. Uses OpenCV's default settings for the given extension.
            bool success = cv::imwrite(filename, imgData.image); 

            if (success)
            {
                total_images_saved_count++; // Increment global counter for saved images.
            }
            else
            {
                std::cerr << "Error: Hilo guardador " << saver_id << " no pudo guardar la imagen: " << filename << std::endl;
            }

            lock.lock(); // Re-acquire the lock before checking imageQueue.empty() in the loop condition
                         // and before potentially waiting on queueCV again.
        }

        // --- Exit Condition for Saver Thread ---
        // If image generation is finished AND the queue is now empty, the saver can exit.
        if (finishedGenerating && imageQueue.empty())
        {
            break; // Exit the while(true) loop.
        }
        // If finishedGenerating is true but queue was not empty, loop continues to process remaining items.
        // If queue became empty but finishedGenerating is false, loop continues to wait for more images.
    }
}

/**
 * @brief Main function: Parses arguments, sets up threads, and prints final summary.
 */
int main(int argc, char *argv[])
{
    // Argument validation.
    if (argc != 6)
    {
        std::cerr << "Uso: " << argv[0] << " <ancho> <alto> <duración_segundos> <fps> <extensión>\n";
        std::cerr << "Ejemplo: " << argv[0] << " 640 480 10 30 png\n";
        return 1;
    }

    ThreadArgs args;
    try
    {
        args.width = std::stoi(argv[1]);
        args.height = std::stoi(argv[2]);
        args.duration_seconds = std::stoi(argv[3]);
        args.fps = std::stod(argv[4]);
        args.image_extension = argv[5];
        // Calculate the total number of images the generator will aim for.
        args.totalImages = static_cast<int>(args.fps * args.duration_seconds);
    }
    catch (...)
    {
        std::cerr << "Error en los argumentos\n";
        return 1;
    }

    args.output_directory = "generated_images"; // Set default output directory name.

    // Validate parsed numeric arguments.
    if (args.width <= 0 || args.height <= 0 || args.fps <= 0 || args.duration_seconds <=0)
    {
        std::cerr << "Error: Ancho, alto, duración y FPS deben ser positivos." << std::endl;
        return 1;
    }

    // If totalImages calculation results in 0 (e.g. due to rounding or very short duration/low fps),
    // inform the user and exit, as no generation work will be done.
    if (args.totalImages == 0 && args.duration_seconds > 0) {
         std::cout << "Advertencia: FPS o duración tan bajos que el total de imágenes objetivo es 0. No se generarán imágenes pero el programa se ejecutará durante la duración especificada." << std::endl;
    } else if (args.totalImages == 0 && args.duration_seconds == 0) {
        std::cout << "Duración es 0 y total de imágenes objetivo es 0. No se realizará ninguna acción." << std::endl;
        return 0;
    }


    // Create the output directory if it does not exist.
    if (!fs::exists(args.output_directory))
    {
        if (!fs::create_directories(args.output_directory))
        {
            std::cerr << "Error: No se pudo crear el directorio de salida: " << args.output_directory << std::endl;
            return 1;
        }
    }

    auto start_global = std::chrono::steady_clock::now(); // Record global start time.

    // --- Thread Creation and Management ---
    // Create and start the image generator thread.
    std::thread generatorThread(imageGenerator, args);

    // Create and start multiple image saver threads.
    std::vector<std::thread> saverThreads;
    for (int i = 0; i < NUM_SAVER_THREADS; ++i)
    {
        saverThreads.emplace_back(imageSaver, args, i); // Pass args and a unique ID to each saver.
    }

    // Wait for the generator thread to complete its execution.
    generatorThread.join();

    // Wait for all saver threads to complete their execution.
    for (int i = 0; i < NUM_SAVER_THREADS; ++i)
    {
        if(saverThreads[i].joinable()) saverThreads[i].join();
    }

    auto end_global = std::chrono::steady_clock::now(); // Record global end time.
    std::chrono::duration<double> total_elapsed = end_global - start_global;

    // --- Final Summary Output ---
    std::cout << "\n--- Resumen Global ---\n";
    std::cout << "Imágenes generadas (contador global): " << total_images_generated_count.load() << "\n";
    std::cout << "Imágenes guardadas (contador global): " << total_images_saved_count.load() << "\n";
    std::cout << std::fixed << std::setprecision(2)
              << "Tiempo total de ejecución: " << total_elapsed.count() << " segundos\n";

    if (total_elapsed.count() > 0)
    {
        double overall_saving_fps = total_images_saved_count.load() / total_elapsed.count();
        std::cout << std::fixed << std::setprecision(2)
                  << "FPS efectivo de guardado (global, basado en tiempo total): " << overall_saving_fps << "\n";

        // Calculate losses based on the current logic (bounded queue, explicit drop tracking).
        int lost_due_to_queue = total_images_enqueued_count.load() - total_images_saved_count.load();
        if (lost_due_to_queue < 0) lost_due_to_queue = 0; // Safety check, should not be negative.
        
        int lost_due_to_delay = total_images_dropped_due_to_delay.load();
        int total_lost_images = lost_due_to_queue + lost_due_to_delay;

        std::cout << "Imágenes perdidas por cola (no alcanzaron a guardarse): " << lost_due_to_queue << "\n";
        std::cout << "Imágenes perdidas por atraso (ni siquiera generadas): " << lost_due_to_delay << "\n";
        std::cout << "TOTAL imágenes perdidas: " << total_lost_images << "\n";
    }

    // Optional: Verify by counting files in the output directory.
    int files_in_directory = 0;
    try
    {
        for (const auto &entry : fs::directory_iterator(args.output_directory))
        {
            if (entry.is_regular_file())
            {
                files_in_directory++;
            }
        }
    }
    catch (const fs::filesystem_error &e)
    {
        std::cerr << "Advertencia: Error al contar archivos en el directorio de salida: " << e.what() << std::endl;
    }

    return 0;
}
